namespace LanguageFactory {

    abstract class / interface Language {

    //  <= 80 chars
        string m_singleLineComment;
        
    //  > 80 chars
        string m_multiLineComment;

        string m_languageType;


    //  prototype 'process' method
        string GetCommentStyle(int commentLength): string;
-----------------------------------------------------
    //  get the name
        public string name  { return m_languageType; }
        
    }

}

let languageObject = LanguageFactory(lang);
let returnstyle[] = languageObject.GetCommentStyle(generatedcomment.length());
let commentToAdd = returnstyle[0] + generated comment + returnstyle[1];


public class cpp {

    string m_singleLineComment "// ";
    string m_multiLineComment "/* . */"
    string m_name = "cpp"

    string[] GetCommentStyle (int commentLength) {
        new string[2] returnstyle
        if blah return m_singleLineComment as returnstyle[0] and "" as returnstyle[1]

        else
            split(.) m_multiLineComment as returnstyle[0, 1]
    }

}

public class python {

    string m_singleLineComment "# ";
    string m_multiLineComment = null;

    string GetCommentStyle (int commentLength) {
        return m_singleLineComment;
    }

}

public class html {

    string m_singleLineComment = null;
    string m_multiLineComment = "<!--.-->";

    string GetCommentStyle (int commentLength) {
        return m_singleLineComment;
    }

}



public enum LanguageType {
    cpp,
    csharp,
    python,
    java,
    javascript,
    typescript,
    html,
    css,
    go,
    php,
    ruby
}



look into typescript and figure out what the equivalent library/module contains
a feature that can search through class files for interface implementations.



..factory should be a "singleton" and initialized on startup


- get a list of all languages by class name

- iterate through list, creating instances of each class
    adding them to a dictionary with their languageID as the 'key'


